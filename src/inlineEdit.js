import * as vscode from "vscode";
import axios from "axios";
import { cleanAiResponse } from "./utils.js";
import { inlineEditState } from "./inlineEditState.js";
import { inlineEditCodeLensProvider } from "./codeLensProvider.js";

export async function handleInlineCodeEdit(uri) {
    const editor = vscode.window.activeTextEditor;
    if (!editor) {
        vscode.window.showErrorMessage("No active text editor found.");
        return;
    }

    const selection = editor.selection;
    const selectedCode = editor.document.getText(selection);

    if (!selectedCode) {
        vscode.window.showErrorMessage("Please select some code to edit.");
        return;
    }

    const instructions = await vscode.window.showInputBox({
        placeHolder: "How should I modify this code?",
        prompt: "Enter instructions for the AI (e.g., 'Refactor to async/await', 'Add error handling Ñƒ')",
        ignoreFocusOut: true
    });

    if (!instructions) {
        return; // User cancelled
    }

    const config = vscode.workspace.getConfiguration("commitMessageGenerator");
    const apiKey = config.get("apiKey");

    if (!apiKey) {
        vscode.window.showErrorMessage("Gemini API Key is missing. Please set it in the extension settings.");
        return;
    }

    await vscode.window.withProgress(
        {
            location: vscode.ProgressLocation.Notification,
            title: "AutoCommit: Inline Edit",
            cancellable: false
        },
        async (progress) => {
            progress.report({ message: "Thinking..." });

            try {
                const response = await axios.post(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`,
                    {
                        systemInstruction: {
                            parts: [
                                {
                                    text: "You are an expert coder. Return ONLY the modified code based on the user's instruction. Do not include markdown formatting (```) or explanation."
                                }
                            ]
                        },
                        contents: [
                            {
                                role: "user",
                                parts: [
                                    {
                                        text: `Code:\n${selectedCode}\n\nInstruction:\n${instructions}`
                                    }
                                ]
                            }
                        ]
                    }
                );

                const generatedContent = response.data?.candidates?.[0]?.content?.parts?.[0]?.text;

                if (!generatedContent) {
                    throw new Error("No content generated by Gemini.");
                }

                const finalCode = cleanAiResponse(generatedContent);

                // Optimistic UI: Insert the new code AFTER the selection
                // so we can show Old (Red) and New (Green) side-by-side
                await editor.edit(editBuilder => {
                    editBuilder.insert(selection.end, finalCode);
                });

                // Range of the Original Text (Red)
                const originalRange = new vscode.Range(selection.start, selection.end);

                // Range of the New Text (Green)
                // It starts where the original ended
                const newStartPos = selection.end;
                const newEndPos = editor.document.positionAt(
                    editor.document.offsetAt(newStartPos) + finalCode.length
                );
                const newRange = new vscode.Range(newStartPos, newEndPos);

                // Apply Highlights
                editor.setDecorations(inlineEditState.redDecorationType, [originalRange]);
                editor.setDecorations(inlineEditState.greenDecorationType, [newRange]);

                // Update State and Trigger CodeLens
                inlineEditState.setPendingState(editor, originalRange, newRange);
                inlineEditCodeLensProvider.refresh();

            } catch (error) {
                const errorMessage = error.response?.data?.error?.message || error.message;
                vscode.window.showErrorMessage(`Error processing request: ${errorMessage}`);
            }
        }
    );
}
